set nocompatible

let ide = 0
let ide_use = {}
" Valid keys:
" python, javascript, coffeescript, typescript, rust, android, java

if filereadable(expand('~/.vimrc_local'))
    source ~/.vimrc_local
endif

" Basic config {{{1
syntax on
set nonu rnu nuw=3
set ruler
set ai si ci
set bs=2
let lwd=getcwd() " cwd at launch
set ts=4 sw=4 et sts=4
set wrap linebreak
try
    set breakindent
catch E518
endtry
set colorcolumn=81,100
" set modeline modelines=5

set foldlevel=100

set nojoinspaces

set hidden
set viminfo+=f1
set splitright

try
    set nofileignorecase
catch E518
endtry
set wildignore+=.git,venv,__pycache__,node_modules,elm-stuff,build,gradle

set mouse=a
set scrolloff=5

cabbrev help tab help
command! Dot tabe ~/.vimrc
command! Q q
" Run selected command
vmap Q "qy:@q<cr>

let mapleader=","

" List characters {{{1
set list
set listchars=tab:Â·\ ,trail:-,extends:>,precedes:<,nbsp:+
autocmd InsertEnter * setlocal nolist
autocmd InsertLeave * setlocal list

" Folded line {{{1
" http://vim.wikia.com/wiki/Customize_text_for_closed_folds
" Set a nicer foldtext function
function! MyFoldText()
    let line = getline(v:foldstart)
    if match(line, '^[ \t]*\(\/\*\|\/\/\)[*/\\]*[ \t]*$') == 0
        let initial = substitute(line, '^\([ \t]\)*\(\/\*\|\/\/\)\(.*\)', '\1\2', '')
        let linenum = v:foldstart + 1
        while linenum < v:foldend
            let line = getline(linenum)
            let comment_content = substitute(line, '^\([ \t\/\*]*\)\(.*\)$', '\2', 'g')
            if comment_content != ''
                break
            endif
            let linenum = linenum + 1
        endwhile
        let sub = initial . ' ' . comment_content
    else
        let sub = line
        let startbrace = substitute(line, '^.*{[ \t]*$', '{', 'g')
        if startbrace == '{'
            let line = getline(v:foldend)
            let endbrace = substitute(line, '^[ \t]*}\(.*\)$', '}', 'g')
            if endbrace == '}'
                let sub = sub.substitute(line, '^[ \t]*}\(.*\)$', '...}\1', 'g')
            endif
        endif
    endif
    let n = v:foldend - v:foldstart + 1
    let info = " " . n . " "
    let sub = sub . repeat(' ', 240)
    let num_w = getwinvar(0, '&number') * getwinvar(0, '&numberwidth')
    let fold_w = getwinvar(0, '&foldcolumn')
    let sub = strpart(sub, 0, winwidth(0) - strlen(info) - num_w - fold_w - 2)
    return sub . info
endfunction
set foldtext=MyFoldText()

" Mouse motion {{{1
nnoremap <ScrollWheelUp> 3<c-y>3k
nnoremap <ScrollWheelDown> 3<c-e>3j
nmap <C-ScrollWheelUp> k
nmap <C-ScrollWheelDown> j
nmap <M-ScrollWheelUp> <c-y>
nmap <M-ScrollWheelDown> <c-e>

nmap <silent> <c-p> 6k
nmap <silent> <c-n> 6j

" Window and tab navigation {{{1
nmap <tab> <c-w><c-w>
nmap <s-tab> <c-w>k
" Go to last tab
au TabLeave * let g:lasttab = tabpagenr()
nmap <silent> g` :exe "tabn ".g:lasttab<cr>

" Terminal.app tab switching {{{1
exec "nmap <silent> \e1 1gt"
exec "nmap <silent> \e2 2gt"
exec "nmap <silent> \e3 3gt"
exec "nmap <silent> \e4 4gt"
exec "nmap <silent> \e5 5gt"
exec "nmap <silent> \e6 6gt"
exec "nmap <silent> \e7 7gt"
exec "nmap <silent> \e8 8gt"
exec "nmap <silent> \e9 9gt"

" Searching {{{1
set incsearch
nmap <silent> <esc><esc> :nohls<cr>
"\|call QuickfixsignsUpdate()<cr>
set timeout timeoutlen=3000 ttimeoutlen=10
" Quickly insert word under cursor
cmap <c-x>w <c-r>=expand('<cword>')<cr>
cmap <c-x><c-w> \<<c-r>=expand('<cword>')<cr>\>
" Quickly replace word under cursor
nmap <leader>* :%s/\<<c-r>=expand('<cword>')<cr>\>/
nmap <leader>g* :%s/<c-r>=expand('<cword>')<cr>/
" Search without hls quickly
nmap <silent> g<space> :nohls<cr>
nnoremap g? :set nohls<cr>?
nnoremap g/ :set nohls<cr>/
nnoremap / :let @/=''<cr>:set hls<cr>/
nnoremap ? :let @/=''<cr>:set hls<cr>?

" Centering with foldcolumn and numberwidth (gutter) {{{1
nmap <silent> [, :let &fdc-=1<cr>
nmap <silent> ], :let &fdc+=1<cr>
nmap <silent> [< :let &fdc=0<cr>
nmap <silent> ]< :let &fdc=12<cr>
nmap <silent> [. :let &nuw-=1<cr>
nmap <silent> ]. :let &nuw+=1<cr>
nmap <silent> [> :let &nuw-=5<cr>
nmap <silent> ]> :let &nuw+=5<cr>

" Text wrapping {{{1
nmap <silent> <leader>j gqip
vmap <silent> <leader>j gq
nmap <silent> <leader>J vipJ

" Add trailing character {{{1
nmap <silent> <leader>, m`A,<esc>``
nmap <silent> <leader>; m`A;<esc>``
nmap <silent> <leader>} m`A}<esc>``
nmap <silent> <leader>) m`A)<esc>``

" Paste and keep cursor position {{{1
nmap <silent> gp p`[
nmap <silent> gP P`[
" Select last pasted text
nmap <silent> gV `[v`]

" Move line {{{1
nmap <silent> <c-j> :move+1<cr>
nmap <silent> <c-k> :move-2<cr>
vmap <silent> <c-j> :move'>+1<cr>gv
vmap <silent> <c-k> :move-2<cr>gv

" Shell title reporting {{{1
set titleold=_sh
set titlestring=â€£%{expand('%:t')}%m
if &term =~ "screen"
    set t_ts=k
    set t_fs=\
endif
if &term =~ "screen" || &term =~ "xterm"
    set title
endif

" Omni-complete {{{1
set complete+=b " Search other open buffers for keywords
" ctrl-space
inoremap <c-@> <c-x><c-o>
function! CleverTab()
   if strpart(getline('.'), 0, col('.')-1) =~ '[A-Za-z_$]\+$'
      return "\<c-n>"
   else
      return "\<tab>"
   endif
endfunction
" Keyword complete
inoremap <silent> <tab> <c-r>=CleverTab()<cr>
" Compilation {{{1
nmap <silent> <f1> :up<cr>:make<cr>
nmap <silent> <leader>w :up<cr>
nmap <silent> <leader>M :up<cr>:make<cr>
function! GetInterpreter()
    return exists('b:interpreter') ? b:interpreter : 'make %< && ./%<'
endfunction
nmap <silent> <leader>r :up<cr>:exec '!'.GetInterpreter()<cr>
if ide
    nmap <silent> <leader>R :up<cr>:exec 'Dispatch '.GetInterpreter()<cr>
endif
nmap <silent> <leader>i :exec '!'.b:repl<cr>
nmap <silent> <leader>I :exec '!'.b:repl_with_file<cr>
nmap ZS :up<cr><c-z>

" }}}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Plugin supported stuff
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Plugins {{{1
filetype off
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
Plugin 'gmarik/Vundle.vim'

Plugin 'jonathanfilip/vim-lucius'  " Colorscheme

Plugin 'scrooloose/nerdtree'
Plugin 'ctrlpvim/ctrlp.vim'

Plugin 'tpope/vim-dispatch'

" Plugin 'jeffkreeftmeijer/vim-numbertoggle'
Plugin 'tpope/vim-surround'
Plugin 'tpope/vim-commentary'
Plugin 'tpope/vim-unimpaired'
Plugin 'tpope/vim-repeat'
Plugin 'tpope/vim-rsi'
Plugin 'Valloric/ListToggle'
Plugin 'kshenoy/vim-signature'
Plugin 'airblade/vim-gitgutter'
Plugin 'tpope/vim-fugitive'

if ide
    Plugin 'embear/vim-localvimrc'
    Plugin 'AndrewRadev/splitjoin.vim'
    Plugin 'Raimondi/Delimitmate'
    Plugin 'alvan/vim-closetag'

    Plugin 'scrooloose/syntastic'
    Plugin 'aquach/vim-http-client'
    Plugin 'Shougo/neocomplete.vim'
    Plugin 'MarcWeber/vim-addon-mw-utils'
    Plugin 'tomtom/tlib_vim'
    Plugin 'garbas/vim-snipmate'
    Plugin 'honza/vim-snippets'

    Plugin 'ap/vim-css-color'
    if has_key(ide_use, 'python')
        Plugin 'davidhalter/jedi-vim'
        " Plugin 'klen/python-mode'
    endif
    if has_key(ide_use, 'javascript')
        Plugin 'pangloss/vim-javascript'
        Plugin 'ternjs/tern_for_vim'
        Plugin 'Quramy/vim-js-pretty-template'
    endif
    if has_key(ide_use, 'coffeescript')
        Plugin 'kchmck/vim-coffee-script'
    endif
    if has_key(ide_use, 'typescript')
        Plugin 'leafgarland/typescript-vim'
        Plugin 'Shougo/vimproc' " Required for tsuquyomi
        Plugin 'Quramy/tsuquyomi' " TypeScript omnicomplete
    endif
    Plugin 'plasticboy/vim-markdown'
    Plugin 'digitaltoad/vim-pug'
    if has_key(ide_use, 'rust')
        Plugin 'rust-lang/rust.vim'
    endif
    if has_key(ide_use, 'android')
        Plugin 'hsanson/vim-android'
    endif
    if has_key(ide_use, 'java')
        Plugin 'artur-shaik/vim-javacomplete2'
    endif
endif

call vundle#end()

filetype plugin indent on

command! VInstall normal VY:@"<cr>:VundleInstall<cr>

nmap [oN :NeoCompleteEnable<cr>
nmap ]oN :NeoCompleteEnable<cr>

" Colorscheme {{{1
try
    function! ApplyTheme()
        colorscheme lucius
        LuciusDark
        " hi clear SignColumn
        " hi link SignColumn LineNr
        hi clear LineNr
        hi clear CursorLineNr
        hi LineNr ctermfg=241 guifg=#626262
        " Make fold column stand out less
        hi clear FoldColumn
        hi FoldColumn ctermfg=250 ctermbg=238 guifg=#bcbcbc guibg=#444444
        hi link FoldColumn LineNr
        " Increase contrast for comments
        hi Comment ctermfg=246 guifg=#949494
        " Make folded stand out less
        hi clear Folded
        hi Folded ctermfg=250 ctermbg=237 guifg=#bcbcbc guibg=#3a3a3a
    endfunction
    command! Theme call ApplyTheme()
    Theme
catch E185
endtry

" snipMate {{{1
if ide
    let g:snipMate = {}
    let g:snipMate.scope_aliases = {}
    let g:snipMate.snippet_version = 1
    imap <c-h> <Plug>snipMateNextOrTrigger
    imap <c-x><c-h> <Plug>snipMateShow
    smap <c-h> <Plug>snipMateNextOrTrigger
    xmap <c-h> <Plug>snipMateVisual
endif

" File navigation {{{1
nmap <silent> <leader>t :NERDTreeToggle<cr>
nmap <silent> <leader>T :NERDTreeFind<cr>
nmap <silent> <leader>e :CtrlP<cr>
nmap <silent> <c-f> :CtrlP<cr>
nmap <silent> <leader>E :CtrlPBuffer<cr>
nmap <leader>c :lcd %:p:h<cr>

let g:ctrlp_map = ''
let g:ctrlp_working_path_mode = ''
call system('which ag')
if v:shell_error == 0
    let g:ctrlp_user_command = 'ag -g "" %s'
endif

" Other editing magic {{{1
if ide
    " splitjoin.vim: gJ, gK
    let g:splitjoin_split_mapping = 'gK'

    " closetag.vim
    let g:closetag_filenames = "*.html,*.hbs,*.jsx,*.xml"

    " delimitMate
    let delimitMate_expand_cr = 1
    let delimitMate_nesting_quotes = ["'","`"]
    let delimitMate_expand_space = 1
    let delimitMate_excluded_regions = "Comment,String"
endif


" HTTP client {{{1
if ide
    let g:http_client_bind_hotkey=0
    map <silent> ,h :HTTPClientDoRequest<cr>
endif

" Local .vimrc {{{1
let g:localvimrc_name = ['__meta/.vimrc']
let g:localvimrc_sandbox = 0
let g:localvimrc_persistent = 2

" }}}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" File types and related plugins
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Remote power {{{1
if !empty($TMUX)
    command! Write w | call system('tmux send-keys -t {last} C-c Up Enter')
    command! W Write
    command! Wa wa | call system('tmux send-keys -t {last} C-c Up Enter')
endif

" Number of spaces {{{1
command! -nargs=1 Spaces setlocal ts=<args> sw=<args> sts=<args>

" Auto readonly {{{1
function! ConfigReadOnly()
    if match(expand('%'), '\<node_modules\>') != -1
        setlocal ro noma
    endif
endfunction
autocmd BufRead * call ConfigReadOnly()

" Switch file {{{1
function! SuperSwitchFile()
    let spec = matchstr(expand('%'), '\.spec\.[jt]sx\?$')
    let ext = matchstr(expand('%'), '\.[^.]\+$')
    if ext == '.ts' || ext == '.js' || ext == '.jsx'
        if !empty(spec)
            exec 'edit %:r:r'.ext
        else
            exec 'edit %:r.spec'.ext
        endif
    elseif ext == '.css' || ext == '.scss' || ext == '.html'
        try
            find %:r.ts
        catch /E345/
            try
                find %:r.js
            catch /E345/
                echo "No js/ts file found"
            endtry
        endtry
    elseif ext == '.c' || ext == '.cpp'
        edit %:r.h
    elseif ext == '.h'
        try
            find %:r.c
        catch /E345/
            try
                find %:r.cpp
            catch /E345/
                echo "No c/cpp file found"
            endtry
        endtry
    endif
endfunction
function! SwitchFile(ext)
    exec 'edit %:r.'.a:ext
endfunction
map <silent> <leader>s :call SuperSwitchFile()<cr>
map <silent> <leader>ah :call SwitchFile('html')<cr>
map <silent> <leader>ac :call SwitchFile('css')<cr>
map <silent> <leader>as :call SwitchFile('scss')<cr>

" neocomplete
let g:neocomplete#enable_ignore_case = 0

" syntastic {{{1
if ide
    let g:syntastic_always_populate_loc_list = 1
    let g:syntastic_auto_loc_list = 2
    " set rulerformat=%30(%l,%c%V%=%P\ \ %#Error#%{SyntasticStatuslineFlag()}%*%)
    " let g:syntastic_stl_format=" %t "
    let g:syntastic_enable_highlighting = 0
    "let g:syntastic_enable_signs = 0
endif

" gitgutter {{{1
let g:gitgutter_sign_column_always = 1
nmap <silent> <Plug>TryFoldOpen @=(foldlevel('.')?'zO':'')<cr>
nmap [c <Plug>GitGutterPrevHunk<Plug>TryFoldOpen
nmap ]c <Plug>GitGutterNextHunk<Plug>TryFoldOpen

" Python .py {{{1
au FileType python
    \ setlocal foldlevel=2|
    \ let b:interpreter="python3 %"|
    \ let b:repl_with_file="python3 -i %"|
    \ let b:repl="python3"
if has_key(ide_use, 'python')
    " Anti-clash config
    let g:jedi#auto_vim_configuration = 0
    let g:jedi#popup_on_dot = 0
    let g:jedi#popup_select_first = 0
    let g:jedi#smart_auto_mappings = 0
    let g:jedi#smart_auto_mappings = 0

    " Consistent with TypeScript plugin
    let g:jedi#goto_command = '<c-]>'
    let g:jedi#rename_command = '<c-^>'

    let g:syntastic_python_checkers = ["pyflakes"]
endif


" JavaScript .js {{{1
au FileType javascript
    \ let b:interpreter="node -es-staging %"|
    \ let b:repl_with_file="node -es-staging"|
    \ let b:repl="node -es-staging"|
    \ setlocal foldmethod=syntax
if has_key(ide_use, 'javascript')
    let g:javascript_enable_domhtmlcss = 1
    let g:syntastic_javascript_checkers = ["eslint"]
    let g:snipMate.scope_aliases['javascript'] = 'javascript,javascript.es6'
    command! EslintFix exec '!eslint --fix "%"' | SyntasticCheck
endif


" CoffeeScript .coffee .{{{1
if has_key(ide_use, 'coffeescript')
    au FileType coffee set makeprg= " Accidental compilation may shield the .coffee
    au FileType coffee setlocal ts=2 sw=2 sts=2
endif

" TypeScript .ts {{{1
if has_key(ide_use, 'typescript')
    let g:typescript_compiler_options='--sourcemap --module commonjs'
    let g:typescript_indent_disable = 1
    let g:syntastic_typescript_checkers = ['tslint', 'tsuquyomi']

    " Workaround for splitjoin somehow breaking for typescript
    au FileType typescript
        \ unlet b:splitjoin_split_callbacks b:splitjoin_join_callbacks|
        \ source ~/.vim/bundle/splitjoin.vim/ftplugin/typescript/splitjoin.vim
endif


" Elm .elm {{{1
au BufRead,BufNewFile *.elm set ft=haskell


" Markdown .md {{{1
au FileType markdown
    \ let &l:makeprg='mark -o "%:r.pdf" "%" && open "%:r.pdf"'|
    \ nmap <buffer> <f1> :up<cr>:Make!<cr>|
    \ setlocal tw=79 |
    \ let &l:commentstring=">%s"
if ide
    au Syntax markdown
        \ syn clear mkdMath |
        \ syn region mkdMath matchgroup=mkdDelimiter start="\\\@<!\$" end="\$" oneline |
        \ syn region mkdMath matchgroup=mkdDelimiter start="\\\@<!\$\$" end="\$\$"
    let g:vim_markdown_folding_disabled = 1
    let g:vim_markdown_frontmatter = 1
endif


" HTML and templating {{{1
au FileType html setlocal matchpairs-=<:>
au BufRead,BufNewFile *.md set ft=markdown
au BufRead,BufNewFile *.hbs,*.swig set ft=html
if ide
    let g:syntastic_html_checkers = []
endif


" Rust .rs {{{1
if has_key(ide_use, 'rust')
    au FileType rust setlocal cc=100|
        \ compiler rustc
endif


" Vim .vim {{{1
au FileType vim setlocal foldmethod=marker foldlevel=0


" YAML .yaml {{{1
au FileType yaml setlocal ts=2 sw=2 sts=2


" Ruby .rb {{{1
au FileType ruby
    \ let b:interpreter="ruby %"|
    \ let b:repl_with_file="irb -I . -r %"|
    \ let b:repl="irb"


" Java .java {{{1
if has_key(ide_use, 'java')
    au FileType java
        \ setlocal omnifunc=javacomplete#Complete
    au FileType java
        \ map <buffer> <leader>i :JCimportAdd<cr>
endif


" Man pages {{{1
au FileType man
    \ setlocal ts=8 nolist nornu nonu cc= fdm=indent fdl=99 so=50
    \|let &titlestring=split(getline('1').getline('2'), '\s\+', 'keepempty')[0].""
    \|nmap q ZQ
    \|normal M0

" let $MANPAGER='cat'
" function! Man(...)
"     let target = a:1
"     if empty(target)
"         let target = expand('<cword>')
"         if empty(target)
"             return
"         endif
"     endif
"     let fname = system('man -w \"'.target.'"')
"     let fname = substitute(fname, '\n', '', '')
"     if match(fname, 'No manual entry for .*') != -1
"         echo fname
"     else
"         new
"         exec 'tabe '.fname
"     endif
" endfunction
" command! -nargs=? Man call Man(<q-args>)
" nmap <silent> K :Man<cr>
"
